(window.webpackJsonp=window.webpackJsonp||[]).push([[115],{526:function(e,n,t){"use strict";t.r(n);var a=t(20),s=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h4",{attrs:{id:"vue3之reactive、ref和torefs"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue3之reactive、ref和torefs"}},[e._v("#")]),e._v(" Vue3之reactive、ref和toRefs")]),e._v(" "),t("p",[e._v("在vue2中，定义数据都是在data中，但在vue3中可以使用reactive和ref来进行数据定义。")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("ref")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("ref是用来创建基础类型的响应式数据，模板默认调用value显示数据，方法中修改需要修改value的值才能修改。")])]),e._v(" "),t("li",[t("p",[e._v("ref可以用于模板和reactive，不仅可以用于响应式还可以用于模板的DOM元素。")])]),e._v(" "),t("li",[t("p",[e._v("ref是一个对象，不丢失响应式，用value属性来存储值，通过.value属性的get和set来实现响应式。")])]),e._v(" "),t("li",[t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//通过ref，可以实现值类型的数据响应式\n<template>\n    <div>ref demo {{ageRef}} {{state.name}}</div>\n</template>\n\n<script>\nimport { ref, reactive } from 'vue'\n\nexport default {\n    name: 'Ref',\n    setup(){\n        const ageRef = ref(15)\n        const nameRef = ref('mery')\n\n        const state = reactive({\n            name: nameRef\n        })\n\n        setTimeout(() => {\n            console.log('ageRef', ageRef.value,'nameRef', nameRef.value)\n            ageRef.value = 20\n            nameRef.value = 'tom'\n            console.log('ageRef', ageRef.value,'nameRef', nameRef.value)\n        },500)\n\n        return{\n            ageRef,\n            state\n        }\n    }\n}\n<\/script>\n\n//ref用于模板的DOM元素\n<template>\n    <p ref=\"elemRef\">今天是周五</p>\n</template>\n\n<script>\nimport { ref, onMounted } from 'vue'\n\nexport default {\n    name: 'refTem',\n    setup(){\n        const elemRef = ref(null)\n\n        onMounted(() => {\n            console.log('reftem', elemRef.value.innerHTML, elemRef.value)\n        })\n\n        return{\n            elemRef\n        }\n    }\n}\n<\/script>\n\n")])])])])])]),e._v(" "),t("li",[t("p",[e._v("reactive")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("reactive用来创建引用类型的响应式数据。")])]),e._v(" "),t("li",[t("p",[e._v("本质是将每一层的数据都解析成proxy对象，reactive的响应式默认都是递归的，改变某一层的值都会递归的调用一边，重新渲染dom。")])]),e._v(" "),t("li",[t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<template>\n   <div>{{state.name}}</div>\n</template>\n\n//js \nsetup(){\n     let state = reactive({name:'aaa'}}) \n     state.name = 'zhangsan'\n     return {state}\n}\n\n")])])])])])]),e._v(" "),t("li",[t("p",[e._v("toRef")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("toRef可以响应对象Object，针对的是某一个响应式对象的属性prop")])]),e._v(" "),t("li",[t("p",[e._v("和对象Object两者保持引用关系，即一个修改另一个也跟着修改。")])]),e._v(" "),t("li",[t("p",[e._v("在不丢失响应式的情况下，把对象数据进行分解和扩散，该对象是响应式对象而不是普通对象。")])]),e._v(" "),t("li",[t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<template>\n    <p>toRef demo - {{ageRef}} - {{state.name}} {{state.age}}</p>\n</template>\n\n<script>\nimport { ref, toRef, reactive, computed } from 'vue'\n\nexport default {\n    name: 'ToRef',\n    setup() {\n        const state = reactive({\n            age: 18,\n            name: 'monday'\n        })\n\n        // // toRef 如果用于普通对象（非响应式对象），产出的结果不具备响应式\n        // const state = {\n        //     age: 18,\n        //     name: 'monday'\n        // }\n\t\t\n        //实现某一个属性的数据响应式\n        const ageRef = toRef(state, 'age')\n\n        setTimeout(() => {\n            state.age = 20\n        }, 1500)\n\n        setTimeout(() => {\n            ageRef.value = 25 // .value 修改值\n        }, 3000)\n\n        return {\n            state,\n            ageRef\n        }\n    }\n}\n<\/script>\n")])])])])])]),e._v(" "),t("li",[t("p",[e._v("toRefs")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("toRefs是针对整个对象的所有属性，目标在于将响应式对象转换为普通对象，普通对象里的每一个属性prop都对应一个ref。")])]),e._v(" "),t("li",[t("p",[e._v("和对象Object两者保持引用关系")])]),e._v(" "),t("li",[t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//利用toRefs将一个响应式对象里面的所有元素取出来\n<template>\n    <p>toRefs demo {{age}} {{name}}</p>\n</template>\n\n<script>\nimport { ref, toRef, toRefs, reactive } from 'vue'\n\nexport default {\n    name: 'ToRefs',\n    setup() {\n        const state = reactive({\n            age: 18,\n            name: 'monday'\n        })\n\n        const stateAsRefs = toRefs(state) // 将响应式对象，变成普通对象\n\n        setTimeout(() => {\n            console.log('age', state.age, 'name', state.name)\n            state.age = 20,\n            state.name = '周一'\n            console.log('age', state.age, 'name', state.name)\n        }, 1500)\n\n        return stateAsRefs\n    }\n}\n<\/script>\n")])])])])])])])])}),[],!1,null,null,null);n.default=s.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{474:function(n,e,o){"use strict";o.r(e);var t=o(20),d=Object(t.a)({},(function(){var n=this,e=n.$createElement,o=n._self._c||e;return o("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[o("p",[n._v("给你一个长度为 n 的链表，每个节点包含一个"),o("code",[n._v("额外增加的随机指针 random")]),n._v("，该指针可以指向链表中的"),o("code",[n._v("任何节点或空节点")]),n._v("。")]),n._v(" "),o("p",[n._v("构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中"),o("code",[n._v("每个新节点的值都设为其对应的原节点的值")]),n._v("。"),o("code",[n._v("新节点的 next 指针和 random 指针也都应指向复制链表中的新节点")]),n._v("，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。")]),n._v(" "),o("p",[n._v("例如，如果原链表中有 X 和 Y 两个节点，其中 X.random --\x3e Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random --\x3e y 。")]),n._v(" "),o("p",[o("code",[n._v("返回复制链表的头节点")]),n._v("。")]),n._v(" "),o("p",[n._v("用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：")]),n._v(" "),o("p",[n._v("val：一个表示 Node.val 的整数。\nrandom_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。\n你的代码 只 接受原链表的头节点 head 作为传入参数。")]),n._v(" "),o("p",[n._v("https://leetcode-cn.com/problems/copy-list-with-random-pointer/")]),n._v(" "),o("p",[n._v("解题思路：random是一个随即指针，指向链表的任意位置。构建A链表的复制链表B，需要保证AB链表保持一种映射关系。")]),n._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[n._v("const copyRandomList = head => {\n    if (!head) return null;\n    const m = new Map();\n    let node = head;\n    // 遍历旧节点，复制各节点值\n    while (node) {\n        m.set(node, new Node(node.val));\n        node = node.next;\n    }\n    node = head;\n    // 遍历旧节点，复制连接关系\n    while (node) {\n        m.get(node).next = node.next ? m.get(node.next) : null;\n        m.get(node).random = node.random ? m.get(node.random) : null;\n        node = node.next;\n    }\n    return m.get(head);\n};\n\n")])])])])}),[],!1,null,null,null);e.default=d.exports}}]);
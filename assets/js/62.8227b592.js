(window.webpackJsonp=window.webpackJsonp||[]).push([[62],{472:function(a,r,t){"use strict";t.r(r);var n=t(20),e=Object(n.a)({},(function(){var a=this,r=a.$createElement,t=a._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h4",{attrs:{id:"得到子序列的最少操作数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#得到子序列的最少操作数"}},[a._v("#")]),a._v(" 得到子序列的最少操作数")]),a._v(" "),t("p",[a._v("给你一个数组 target ，包含若干 互不相同 的整数，以及另一个整数数组 arr ，arr 可能 包含重复元素。")]),a._v(" "),t("p",[a._v("每一次操作中，你可以在 arr 的任意位置插入任一整数。比方说，如果 arr = [1,4,1,2] ，那么你可以在中间添加 3 得到 [1,4,3,1,2] 。你可以在数组最开始或最后面添加整数。")]),a._v(" "),t("p",[a._v("请你返回 最少 操作次数，使得 target 成为 arr 的一个子序列。")]),a._v(" "),t("p",[a._v("一个数组的 子序列 指的是删除原数组的某些元素（可能一个元素都不删除），同时不改变其余元素的相对顺序得到的数组。比方说，[2,7,4] 是 [4,2,3,7,2,1,4] 的子序列（加粗元素），但 [2,4,2] 不是子序列。")]),a._v(" "),t("h5",{attrs:{id:"示例-1"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#示例-1"}},[a._v("#")]),a._v(" 示例 1：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("输入：target = [5,1,3], arr = [9,4,2,3,4]\n输出：2\n解释：你可以添加 5 和 1 ，使得 arr 变为 [5,9,4,1,2,3,4] ，target 为 arr 的子序列。\n")])])]),t("p",[t("strong",[a._v("示例 2：")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("输入：target = [6,4,8,1,3,2], arr = [4,7,6,2,3,8,6,1]\n输出：3\n")])])]),t("p",[t("img",{attrs:{src:"C:%5CUsers%5Cliangyu%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210726195935608.png",alt:"image-20210726195935608"}})]),a._v(" "),t("p",[a._v("target中元素互不相同，那么可以通过map记录各数字及对应的下标。\n然后比较修改arr，在target中没出现的元素可以去除，在剩下的元素中查找target的最大子序列，对应的下标就需要满足升序，即根据下标求最长的升序子序列。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("var minOperations = function (target, arr) {\n\n    //把taget中的数字转换成value:index的键值对存储在map中\n    let targetmap = new Map()\n    for (let i = 0; i < target.length; i++) {\n        targetmap.set(target[i], i)\n    }\n    //对arr进行下标映射，寻找target和arr的最长递增子序列\n    const maxsonarr = []\n    for (let item of arr) {\n        //如果arr中的元素存在于target中，则根据其下标添加进单调递增的结果数组中\n        if (targetmap.has(item)) {\n            let curval = targetmap.get(item)\n            //通过二分查找找到节点在maxsonarr数组中应该出现的位置\n            //比如说maxsonarr数组中空的，则直接push\n            //如果maxsonarr数组中是[0,2],当前的curval是1，则通过二分查找会得到index为1,这时1比2小，所以找到的适合的index就是1，            需要把2的位置让给1\n            //如果reuslt数组中是[0,1],当前的curval是2，则需要把maxsonarr变成[0,1,2]才是符合条件的。\n            let indexinresult = binarySearch(maxsonarr, curval)\n            if (indexinresult != maxsonarr.length) {\n                maxsonarr[indexinresult] = curval\n            } else {\n                maxsonarr.push(curval)\n            }\n\n        }\n    }\n    return target.length - maxsonarr.length\n    //\n\n};\nfunction binarySearch(maxsonarr, curval) {\n    const size = maxsonarr.length\n    //子数组为0或者子数组的最大值小于curval\n    if (size == 0 || maxsonarr[size - 1] < curval) {\n        return size\n    }\n    let low = 0;\n    let high = size - 1\n    while (low < high) {\n        let mid = Math.floor((high - low) / 2)+low\n        if (maxsonarr[mid] < curval) {\n            low=mid+1\n        } else {\n            high=mid\n        }\n    }\n    return low\n}\n\n")])])])])}),[],!1,null,null,null);r.default=e.exports}}]);
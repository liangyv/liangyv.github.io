(window.webpackJsonp=window.webpackJsonp||[]).push([[79],{488:function(l,v,t){"use strict";t.r(v);var _=t(20),e=Object(_.a)({},(function(){var l=this,v=l.$createElement,t=l._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":l.$parent.slotKey}},[t("h4",{attrs:{id:"前端性能优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前端性能优化"}},[l._v("#")]),l._v(" 前端性能优化")]),l._v(" "),t("h5",{attrs:{id:"一、页面加载和渲染过程优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、页面加载和渲染过程优化"}},[l._v("#")]),l._v(" 一、页面加载和渲染过程优化")]),l._v(" "),t("ul",[t("li",[t("p",[l._v("CRP(关键渲染路径)优化")]),l._v(" "),t("p",[l._v("关键渲染路径是浏览将HTML、CSS、JS转换为在屏幕上呈现的像素内容所经历的一系列步骤，即浏览器渲染流程。为尽快实现首次渲染，可在以下三个方面实现：")]),l._v(" "),t("ul",[t("li",[t("p",[l._v("关键资源的数量：可能阻止网页首次渲染的资源")])]),l._v(" "),t("li",[t("p",[l._v("关键路径长度：获取所有关键资源所需的往返次数或总时间")])]),l._v(" "),t("li",[t("p",[l._v("关键字节：所有关键资源传送文件大小的总和")])])])]),l._v(" "),t("li",[t("p",[l._v("优化DOM")]),l._v(" "),t("ul",[t("li",[l._v("删除不必要的代码和注释包括空格，尽量做到最小化文件")]),l._v(" "),t("li",[l._v("利用GZIP压缩文件")]),l._v(" "),t("li",[l._v("结合HTTP缓存文件")])])]),l._v(" "),t("li",[t("p",[l._v("优化CSSOM")]),l._v(" "),t("ul",[t("li",[l._v("DOM和CSSOM通常是并行构建的，所以CSS加载不会阻塞DOM的解析")]),l._v(" "),t("li",[l._v("CSS资源加载完成才开始渲染DOM，所以CSS加载会阻塞DOM渲染")]),l._v(" "),t("li",[l._v("所以CSSOM缩小、压缩以及缓存同样重要，可从一下几个方面去优化\n"),t("ul",[t("li",[l._v("减少关键CSS元素数量")]),l._v(" "),t("li",[l._v("声明样式表时，密切关注媒体查询的类型")])])])])]),l._v(" "),t("li",[t("p",[l._v("优化JS")]),l._v(" "),t("ul",[t("li",[l._v("浏览器遇到script标记时，会阻止解析器继续操作，直到CSSOM构建完毕，js才会运行并继续完成DOM构建过程")]),l._v(" "),t("li",[l._v("async：添加script属性之后，浏览器遇到该标记时会继续解析DOM，同时脚本也不会被CSSOM阻止，就不会阻止CRP")]),l._v(" "),t("li",[l._v("defer：区别在于，脚本需要等文档解析后执行，而async脚本在文档解析时位于后台运行（下载的过程不会阻塞DOM，但执行会）")]),l._v(" "),t("li",[l._v("当脚本不会修改DOM/CSSOM时，推荐使用async")]),l._v(" "),t("li",[l._v("预加载    ——preload & prefetch")]),l._v(" "),t("li",[l._v("DNS预解析  ——DNS-prefetch")])])]),l._v(" "),t("li",[t("p",[l._v("浏览器重绘和重排(回流)")]),l._v(" "),t("ul",[t("li",[t("p",[l._v("回流一定会引起重绘，重绘不一定会引起回流")])]),l._v(" "),t("li",[t("p",[l._v("重绘：页面中样式的改变并不影响他在文档流中的位置，例如color、bgcolor、visibility等，浏览器会将新样式赋予给元素并重新赋予绘制它。")])]),l._v(" "),t("li",[t("p",[l._v("回流：当渲染树种部分或全部元素的尺寸、结构或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程。")])]),l._v(" "),t("li",[t("p",[l._v("导致回流的操作：")]),l._v(" "),t("ul",[t("li",[t("p",[l._v("页面首次渲染")])]),l._v(" "),t("li",[t("p",[l._v("浏览器窗口大小位置改变")])]),l._v(" "),t("li",[t("p",[l._v("元素尺寸/位置发生改变元素内容变化（文字数量/图片大小等）")])]),l._v(" "),t("li",[t("p",[l._v("元素字体大小变化")])]),l._v(" "),t("li",[t("p",[l._v("添加/删除可见的DOM元素")])]),l._v(" "),t("li",[t("p",[l._v("激活CSS伪类，例：hover")])]),l._v(" "),t("li",[t("p",[l._v("查询某些属性/调用某些方法")])]),l._v(" "),t("li",[t("p",[l._v("一些常用且会导致回流的属性和方法：")]),l._v(" "),t("div",{staticClass:"language-text extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[l._v("clientWidth、clientHeight、clientTop、clientLeft、offsetWidth、offsetHeight、offsetTop、offsetLeft、scrollWidth、scrollHeight、scrollTop、scrollLeft、scrollLeftscrollIntoView()、scrollIntoViewIfNeeded()、getComputedStyle()、\ngetBoundingClientRect()、scrollTo()\n")])])])])])]),l._v(" "),t("li",[t("p",[l._v("性能影响：")]),l._v(" "),t("ul",[t("li",[t("p",[l._v("回流比重绘代价更高")])]),l._v(" "),t("li",[t("p",[l._v("浏览器会频繁的回流/重绘操作进行优化，浏览器会维护一个队列，将所有引起回流和重绘的操作放入队列中，若队列种的任务数量/时间间隔达到一个阈值时，浏览器会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。")])]),l._v(" "),t("li",[t("p",[l._v("访问以下属性时，浏览器会立刻清空队列：")])]),l._v(" "),t("li",[t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[l._v("clientWidth、clientHeight、clientTop、clientLeft\noffsetWidth、offsetHeight、offsetTop、offsetLeft\nscrollWidth、scrollHeight、scrollTop、scrollLeft\nwidth、height\ngetComputedStyle()\ngetBoundingClientRect()\n")])])])])])]),l._v(" "),t("li",[t("p",[l._v("如何避免")]),l._v(" "),t("ul",[t("li",[t("p",[l._v("CSS")]),l._v(" "),t("ul",[t("li",[l._v("避免使用table布局")]),l._v(" "),t("li",[l._v("最好在DOM树的最末端改变class")]),l._v(" "),t("li",[l._v("避免设置多层内联样式")]),l._v(" "),t("li",[l._v("将动画效果应用到position属性为absolute/fixed的元素上")]),l._v(" "),t("li",[l._v("避免使用CCS表达式，例如calc()")])])]),l._v(" "),t("li",[t("p",[l._v("JS")]),l._v(" "),t("ul",[t("li",[l._v("避免频繁操作样式，最好以一次性重写style属性，或将样式列表定义为class并一次性更改class属性")]),l._v(" "),t("li",[l._v("避免频繁操作DOM，创建一个documentFragment，在其上面应用所有的DOM操作，最后再将其添加到文档中")]),l._v(" "),t("li",[l._v("先将元素设置为display:none，操作结束后再将其显示出来，在display属性为none的元素上进行的DOM操作不会引发回流和重绘")]),l._v(" "),t("li",[l._v("避免频繁读取会引发回流/重绘的属性，若确实需要可用一个变量缓存")]),l._v(" "),t("li",[l._v("具有复杂动画的元素使用绝对定位，示器脱离文档流，否则会引起父元素及后续元素频繁回流")])])]),l._v(" "),t("li",[t("p",[l._v("图片懒加载")]),l._v(" "),t("ul",[t("li",[t("p",[l._v("避免一次性加载过多的图片导致请求阻塞")])]),l._v(" "),t("li",[t("p",[l._v("原理：将页面中的img标签src指向一张小图片/src为空，然后定义data-src(可自定义)属性指向真实的图片。src指向一张默认的图片，否则当src为空时也会想服务器发送一次请求，可以指向loading的地址，此处的图片要指定宽高。")])]),l._v(" "),t("li",[t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token operator"}},[l._v("<")]),l._v("img src"),t("span",{pre:!0,attrs:{class:"token operator"}},[l._v("=")]),t("span",{pre:!0,attrs:{class:"token string"}},[l._v('"default.jpg"')]),l._v(" data"),t("span",{pre:!0,attrs:{class:"token operator"}},[l._v("-")]),l._v("src"),t("span",{pre:!0,attrs:{class:"token operator"}},[l._v("=")]),t("span",{pre:!0,attrs:{class:"token string"}},[l._v('"666.jpg"')]),l._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[l._v("/")]),t("span",{pre:!0,attrs:{class:"token operator"}},[l._v(">")]),l._v("\n")])])])]),l._v(" "),t("li",[t("p",[l._v("当载入页面时，先把可视区域内的img标签的data-src属性赋值给src，然后箭头ing滚动事件，把用户即将看到的图片加载，便实现了懒加载。")])])])]),l._v(" "),t("li",[t("p",[l._v("事件委托")]),l._v(" "),t("ul",[t("li",[l._v("利用js事件冒泡机制把原本需要绑定在子元素的响应时间委托给父元素，让父元素担当事件监听的职务。")]),l._v(" "),t("li",[l._v("可大量减少内存占用，减少事件注册")]),l._v(" "),t("li",[l._v("新增元素实现动态绑定事件")])])])])])])])]),l._v(" "),t("h5",{attrs:{id:"二、渲染完成后的页面交互优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、渲染完成后的页面交互优化"}},[l._v("#")]),l._v(" 二、渲染完成后的页面交互优化")]),l._v(" "),t("ul",[t("li",[l._v("防抖/节流   debounce /throttle")]),l._v(" "),t("li",[l._v("输入搜索时，可利用防抖等优化方式，减少http请求")]),l._v(" "),t("li",[l._v("节流函数：只允许一个函数在N秒内执行一次，滚动条调接口时，可以用节流throttle等优化方式，减少http请求")])]),l._v(" "),t("h5",{attrs:{id:"三、vue相关性能优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三、vue相关性能优化"}},[l._v("#")]),l._v(" 三、Vue相关性能优化")]),l._v(" "),t("ul",[t("li",[l._v("运行时，可借助Chrome devtools工具查看运行时性能问题，分析加载性能问题")]),l._v(" "),t("li",[l._v("运行时性能主要关注Vue应用初始化之后对CPU、内存、本地存储等资源的占用，以及对用户交互的及时响应。")]),l._v(" "),t("li",[l._v("优化建议：\n"),t("ul",[t("li",[l._v("引入生产环境的Vue文件\n"),t("ul",[t("li",[l._v("vue提供的一些提示信息没用且会增加应用的体积，当使用webpack或Browserify类似的构建工具时，vue源码会根据process.env.NODE_ENV决定是否启用生产环境模式，默认情况为开发环境模式。在webpack与bowserify种都有方法来覆盖此变量，以启用vue的生产环境模式，同时在构建过程中警告语句也会被压缩工具去除。")])])]),l._v(" "),t("li",[l._v("使用单文件组件预编译模板\n"),t("ul",[t("li",[l._v("当使用DOM内模板或JS内的字符串模板时，模板会在运行时被编译为渲染函数。通常情况下这个过程已经足够快了，但对性能敏感的应用还是最好避免这种用法。")]),l._v(" "),t("li",[l._v("预编译模板最简单的方式就是使用单文件组件，相关的构建设置会自动把预编译处理好，所以构建好的代码已经包含了编译出来的渲染函数而不是原始的模板字符串。")])])]),l._v(" "),t("li",[l._v("提取组件的CSS到单独的文件\n"),t("ul",[t("li",[l._v("当使用单文件组件时，组件内的CSS会以"),t("style")])])])])])])])}),[],!1,null,null,null);v.default=e.exports}}]);
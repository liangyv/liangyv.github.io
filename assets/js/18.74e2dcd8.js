(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{429:function(t,i,s){"use strict";s.r(i);var l=s(20),n=Object(l.a)({},(function(){var t=this,i=t.$createElement,s=t._self._c||i;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h4",{attrs:{id:"this指向"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#this指向"}},[t._v("#")]),t._v(" this指向")]),t._v(" "),s("ul",[s("li",[t._v("全局作用域下的this指向window")]),t._v(" "),s("li",[t._v("如果给元素的事件行为绑定函数，那么函数中的this指向当前被绑定的那个元素")]),t._v(" "),s("li",[t._v("函数中的this，要看函数执行前有没有 . , 有 . 的话，点前面是谁，this就指向谁，如果没有点，指向window")]),t._v(" "),s("li",[t._v("自执行函数中的this永远指向window")]),t._v(" "),s("li",[t._v("定时器中函数的this指向window")]),t._v(" "),s("li",[t._v("构造函数中的this指向当前的实例")]),t._v(" "),s("li",[t._v("call、apply、bind可以改变函数的this指向")]),t._v(" "),s("li",[t._v("箭头函数中没有this，如果输出this，就会输出箭头函数定义时所在的作用域中的this")])])])}),[],!1,null,null,null);i.default=n.exports}}]);
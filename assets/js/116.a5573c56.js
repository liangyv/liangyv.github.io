(window.webpackJsonp=window.webpackJsonp||[]).push([[116],{527:function(t,e,n){"use strict";n.r(e);var o=n(20),r=Object(o.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h4",{attrs:{id:"vue3之生命周期"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vue3之生命周期"}},[t._v("#")]),t._v(" Vue3之生命周期")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://img-blog.csdnimg.cn/a591b3781c3e4bc3be19b3383bc745b6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeGlhb0xpYW5nIG8=,size_15,color_FFFFFF,t_70,g_se,x_16",alt:"在这里插入图片描述"}}),t._v(" "),n("img",{attrs:{src:"https://img-blog.csdnimg.cn/4134f6c8b9c949b59e4f4e3d77d94cac.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeGlhb0xpYW5nIG8=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center",alt:"在这里插入图片描述"}})]),t._v(" "),n("p",[n("strong",[t._v("主要Vue生命周期事件被分为两个钩子，分别在事件之前和之后调用，vue应用程序中有4个主要事件(8个钩子)")]),t._v("：")]),t._v(" "),n("ul",[n("li",[t._v("创建 ---- 在组建创建时执行")]),t._v(" "),n("li",[t._v("挂载 ---- DOM被挂载时执行")]),t._v(" "),n("li",[t._v("更新 ---- 当响应数据被修改时执行")]),t._v(" "),n("li",[t._v("销毁 ---- 在元素被销毁之前立即执行")])]),t._v(" "),n("p",[n("strong",[t._v("在【options API】中，生命周期钩子是被暴露在vue实例上的选项，我们只需要调用使用即可。")])]),t._v(" "),n("p",[n("strong",[t._v("在【composition API】中，我们需要将生命周期钩子导入项目，然后才能使用。")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("import {onMounted} from 'vue'\n")])])]),n("p",[n("strong",[t._v("在这里，beforecreate和created被setup方法本身所替代，我们在在setup中将会访问到9个生命周期：")])]),t._v(" "),n("ul",[n("li",[n("p",[t._v("onBeforeMount：在挂载之前被调用，渲染函数render首次被调用")])]),t._v(" "),n("li",[n("p",[t._v("onMounted：组件挂载时调用")])]),t._v(" "),n("li",[n("p",[t._v("onBeforeUpdate：数据更新时调用，发生在虚拟DOM打补丁之前。")])]),t._v(" "),n("li",[n("p",[t._v("onUpdated：因数据更改导致的虚拟DOM重新渲染和打补丁时调用")])]),t._v(" "),n("li",[n("p",[t._v("onBeforeUnmount：在卸载组件实例之前调用，此阶段的实例依旧是正常的。")])]),t._v(" "),n("li",[n("p",[t._v("onActivated：被keep-alive缓存的组件激活时调用")])]),t._v(" "),n("li",[n("p",[t._v("onDeactivated：被keep-alive缓存的组件停用时调用")])]),t._v(" "),n("li",[n("p",[t._v("onErrorCaptured：当捕获一个来自子孙组件的错误时被调用，有三个参数：错误对象、发生错误的组件实例、一个包含错误来源信息的字符串；此钩子会返回false来阻止改错误继续向上传播。")])]),t._v(" "),n("li",[n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("<script>\nimport { onMounted } from 'vue'\n export default {\n \tsetup(){\n \t\tonMounted(()=>{\n \t\t\tconsole.log('生命周期----onMounted')\n \t\t})\n \t}\n }\n<\/script>\n")])])]),n("p",[n("strong",[t._v("在组合API中，使用setup()方法替换了beforeCreate和created，那么在这两个生命周期中的方法将放在setup中执行")])]),t._v(" "),n("p",[n("strong",[t._v("beforeMount()和onBeforeMount()")])]),t._v(" "),n("p",[t._v("在组件DOM实际渲染之前调用，此时根元素还不存在，在选项API中，可使用this.$el来 访问；在组合API中，想访问的话就必须在根元素上使用ref。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("//选项API\nbeforeMount(){\n\tconsole.log('beforeMount',this.$el)\n}\n\n//组合API\n<template>\n\t<div ref=\"root\">\n\t\tHello~\n\t</div>\n</template>\n import {ref,onBeforeMount} from 'vue'\n export default{\n \tsetup(){\n \t\tconst root = ref(null)\n \t\tonBeforeMount(()=>{\n \t\t\tconsole.log('onBeforeMount',root.value)\n \t\t})\n \t\treturn {\n \t\troot\n \t\t}\n \t},\n \t  beforeMount() {\n      console.log('beforeMount',this.$el)\n    }\n }\n")])])]),n("p",[n("strong",[t._v("mounted()和onMounted()")])]),t._v(" "),n("p",[t._v("在组件的第一次选然后调用，此时元素可用，允许直接DOM访问。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("import { ref, onMounted } from 'vue'\n \n\n export default {\n   // 组合 API\n   setup() {    \n \n     const root = ref(null)\n     \n     onMounted(() => {\n       console.log(root.value)\n     })\n\n     return {\n       root\n     }\n   },\n   // 选项 API \n   mounted() {\n     console.log(this.$el)\n   }\n } \n")])])]),n("p",[n("strong",[t._v("beforeUpdate()和onBeforeUpdate()")])]),t._v(" "),n("p",[t._v("数据更新时调用，发生在虚拟DOM打补丁之前。")]),t._v(" "),n("p",[t._v("beforeUpdate对于跟踪对组件的编辑次数，甚至跟踪创建撤销功能的操作很有用。")]),t._v(" "),n("p",[n("strong",[t._v("updated()和onUpdated()")])]),t._v(" "),n("p",[t._v("DOM更新后，updated的方法就会调用")]),t._v(" "),n("p",[n("strong",[t._v("beforeUnmount()和onBeforeUnmounted()")])]),t._v(" "),n("p",[t._v("在卸载组件实例之前调用")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("//选项API\nexport default{\nmounted(){\n\tconsole.log('mounted')\n},\nbeforeUnmount(){\n\tconsole.log('unmount')\n}\n}\n\n//组合API\nimport { onMounted,onBeforeUnmount } from 'vue'\nexport default {\n\tsetup(){\n\t\tonMounted(()=>{\n\t\t\tconsole.log('mount')\n\t\t})\n\t\tonBeforeUnmount(()=>{\n\t\t\tconsole.log('unmount')\n\t\t})\n\t}\n}\n")])])]),n("p",[n("strong",[t._v("unmounted()和onUnmounted()")])]),t._v(" "),n("p",[t._v("卸载组件实例后调用，调用此钩子时，组件实例的所有指令都被解除绑定，所有事件侦听器都被移除，所有子组件实例被卸载。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("import { onUnmouted } from 'vue'\n\nexport default {\n\t//组合API\n\tsetup(){\n\t\tonUnmounted(()=>{\n\t\t\tconsole.log('unmounted')\n\t\t})\n\t},\n\t//选项API\n\tunmounted(){\n\t\tconsole.log('unmounted')\n\t}\n}\n")])])]),n("p",[n("strong",[t._v("actived()和onActivated()")])]),t._v(" "),n("p",[t._v("被keep-alive缓存的组件激活时调用")]),t._v(" "),n("p",[n("strong",[t._v("deactivated()和onDeactivated()")])]),t._v(" "),n("p",[t._v("被keep-alive缓存的组件停用时调用。")])])]),t._v(" "),n("p",[t._v("vue3还提供了两个可用于调试目的的钩子")]),t._v(" "),n("ul",[n("li",[t._v("onRenderTracked")]),t._v(" "),n("li",[t._v("onRenderTriggered")])]),t._v(" "),n("p",[t._v("这两个事件都带有一个debugger event，该事件会告诉你哪个操作跟踪了组件以及该操作的目标对象和键。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("export default {\n    onRenderTriggered(e) {\n       debugger\n       // 检测什么依赖造成了组件的重新渲染\n    }\n}\n\n")])])])])}),[],!1,null,null,null);e.default=r.exports}}]);
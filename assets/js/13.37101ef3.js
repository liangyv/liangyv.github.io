(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{423:function(v,_,t){"use strict";t.r(_);var s=t(20),a=Object(s.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("p",[v._v("在理解重绘和重排之前，我们先回忆一下浏览器的渲染页面的过程")]),v._v(" "),t("h2",{attrs:{id:"浏览器渲染页面的过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浏览器渲染页面的过程"}},[v._v("#")]),v._v(" 浏览器渲染页面的过程")]),v._v(" "),t("p",[v._v("浏览器"),t("strong",[v._v("请求、加载、渲染")]),v._v("一个页面的过程主要是：")]),v._v(" "),t("blockquote",[t("ul",[t("li",[v._v("DNS 查询（"),t("strong",[v._v("DNS的目的")]),v._v("："),t("em",[v._v("客户端传入网站域名，到DNS列表中找相对应的IP返回到客户端，客户端根据IP找到对应的服务器，就可以向服务器发送请求")]),v._v("）")]),v._v(" "),t("li",[v._v("TCP 连接")]),v._v(" "),t("li",[v._v("HTTP 请求即响应")]),v._v(" "),t("li",[v._v("服务器响应")]),v._v(" "),t("li",[v._v("客户端渲染")])])]),v._v(" "),t("p",[v._v("这里主要讨论"),t("strong",[v._v("客户端渲染")]),v._v("，即浏览器对于页面的渲染，主要有以下五个步骤：")]),v._v(" "),t("blockquote",[t("ul",[t("li",[v._v("浏览器对HTML源代码进行解析，并构建DOM树（每个HTML标签都有一个相对应的节点）")]),v._v(" "),t("li",[v._v("浏览器解析CSS代码，构建CSSOM树")]),v._v(" "),t("li",[v._v("将DOM和CSSOM合并为一个渲染树")]),v._v(" "),t("li",[v._v("根据渲染树进行布局，并计算每个元素的几何属性")]),v._v(" "),t("li",[v._v("将每个元素的几何属性绘制到屏幕上")])])]),v._v(" "),t("h2",{attrs:{id:"重绘"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#重绘"}},[v._v("#")]),v._v(" 重绘")]),v._v(" "),t("p",[v._v("重绘就是当页面元素样式改变不影响元素在文档流中的位置时（如background-color，border-color，visibility），但是元素的几何尺寸没有变 ，浏览器只会将新样式赋予元素并进行重新绘制操作。")]),v._v(" "),t("h2",{attrs:{id:"回流-重排"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#回流-重排"}},[v._v("#")]),v._v(" 回流（重排）")]),v._v(" "),t("p",[v._v("回流就是当render tree中的一部分或全部因为"),t("strong",[v._v("元素的规模尺寸、布局、隐藏")]),v._v("等改变时，浏览器重新渲染部分DOM或全部DOM的过程。回流也被称为重排，其实从字面上来看，重排更容易让人形象易懂（即重新排版整个页面）。")]),v._v(" "),t("h2",{attrs:{id:"什么情况会触发重排和重绘"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么情况会触发重排和重绘"}},[v._v("#")]),v._v(" 什么情况会触发重排和重绘？")]),v._v(" "),t("p",[v._v("任何改变用来构建渲染树的信息都会导致一次重排或重绘。")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("页面渲染初始化（至少触发一次重排/回流）")])]),v._v(" "),t("li",[t("p",[v._v("添加、删除、更新DOM节点")])]),v._v(" "),t("li",[t("p",[v._v("元素位置改变，元素尺寸改变（边距、填充、边框、宽高等）")])]),v._v(" "),t("li",[t("p",[v._v("通过"),t("code",[v._v("display: none")]),v._v("隐藏一个DOM节点-触发重排和重绘")])]),v._v(" "),t("li",[t("p",[v._v("通过"),t("code",[v._v("visibility: hidden")]),v._v("隐藏一个DOM节点-只触发重绘，因为没有几何变化")])]),v._v(" "),t("li",[t("p",[v._v("移动或者给页面中的DOM节点添加动画")])]),v._v(" "),t("li",[t("p",[v._v("添加一个样式表，调整样式属性")])]),v._v(" "),t("li",[t("p",[v._v("用户行为，例如调整窗口大小，改变字号，或者滚动、浏览器窗口尺寸变化、内容变化（如input框输入内容变化）")])])]),v._v(" "),t("blockquote",[t("h2",{attrs:{id:"回流必定引起重绘-重绘不一定引起回流"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#回流必定引起重绘-重绘不一定引起回流"}},[v._v("#")]),v._v(" 回流必定引起重绘，重绘不一定引起回流")])]),v._v(" "),t("h2",{attrs:{id:"css中避免回流、重绘"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#css中避免回流、重绘"}},[v._v("#")]),v._v(" CSS中避免回流、重绘")]),v._v(" "),t("p",[v._v("1.尽可能在DOM树的最末端改变class")]),v._v(" "),t("p",[v._v("2.避免设置多层内联样式")]),v._v(" "),t("p",[v._v("3.动画效果应用到position属性为absolute或fixed的元素上")]),v._v(" "),t("p",[v._v("4.避免使用table布局")]),v._v(" "),t("p",[v._v("5.使用css3硬件加速，可以让transform、opacity、filters等动画效果不会引起回流重绘")]),v._v(" "),t("h2",{attrs:{id:"js操作避免回流、重绘"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#js操作避免回流、重绘"}},[v._v("#")]),v._v(" JS操作避免回流、重绘")]),v._v(" "),t("p",[v._v("1.避免使用JS一个样式修改完接着改下一个样式，最好一次性更改CSS样式，或者将样式列表定义为class的名称")]),v._v(" "),t("p",[v._v("2.避免频繁操作DOM，使用文档片段创建一个子树，然后再拷贝到文档中")]),v._v(" "),t("p",[v._v("3.先隐藏元素，进行修改后再显示该元素，因为display:none上的DOM操作不会引发回流和重绘")]),v._v(" "),t("p",[v._v("4.避免循环读取offsetLeft等属性，在循环之前把它们用一个变量存起来")])])}),[],!1,null,null,null);_.default=a.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[113],{525:function(t,e,a){"use strict";a.r(e);var s=a(20),n=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h4",{attrs:{id:"vue3入门"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue3入门"}},[t._v("#")]),t._v(" Vue3入门")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("根实例初始化不同")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("2.x中通过"),a("code",[t._v("new Vue()")]),t._v("的方法来初始化")]),t._v(" "),a("ul",[a("li",[a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("import App from './App.vue'\nnew Vue({\n\tstore,\n\trender:h => h(App)\n}).$mount('#app')\n")])])])])])]),t._v(" "),a("li",[a("p",[t._v("3.x中vue不再是一个构造函数，通过"),a("code",[t._v("createApp")]),t._v("方法初始化")]),t._v(" "),a("ul",[a("li",[a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("import App from './App.vue'\ncreateApp(App).use(store).mount('#app')\n")])])])])])])])]),t._v(" "),a("li",[a("p",[t._v("ref或者reactive代替了data中的变量：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("在2.x中通过组件data的方法来定义一些当前组件需要的数据：")]),t._v(" "),a("ul",[a("li",[a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("data(){\n\treturn{\n\t\tname:'test',\n\t\tlist:[]\n\t}\n}\n")])])])])])]),t._v(" "),a("li",[a("p",[t._v("在3.x中通过ref或者reactive创建响应式对象：")]),t._v(" "),a("ul",[a("li",[a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("import {ref,reactive} from 'vue'\n\nsetup(){    //在setup中去定义参数，然后return出去\n\tconst name = ref('test')\n\tconst state = reactive({\n\t\tlist:[]\n\t})\n\treturn {\n\t\tname,\n\t\tstate\n\t}\n}\n\nref将给定的值创建一个响应式的数据对象并复制初始值(int/string),reactive可以直接定义复杂的响应式对象\n")])])])])])])])]),t._v(" "),a("li",[a("p",[t._v("methods中定义的方法也可以写在setup中")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("在2.x中methods来定义一些当前组件内部方法")]),t._v(" "),a("ul",[a("li",[a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("methods:{\n\tgetData(){\n\t\t//\n\t},\n}\n")])])])])])]),t._v(" "),a("li",[a("p",[t._v("在3.x中直接在setup方法中定义并return")]),t._v(" "),a("ul",[a("li",[a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("setup(){\n\tconst getData = ()=>{\n\t\tconsole.log('getData')\n\t}\n\t\n\treturn{\n\t\tgetData\n\t}\n}\n")])])])])])])])]),t._v(" "),a("li",[a("p",[t._v("不能使用EventBus")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("在2.x中通过EventBus的方法来实现组件通信")]),t._v(" "),a("ul",[a("li",[a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("var EventBus = new Vue()\nVue.prototype.$EventBus = EventBus\n\nthis.$EvenetBus.$on()   this.$EventBus.$emit()\n")])])])])])]),t._v(" "),a("li",[a("p",[t._v("在3.x中移除了$on，$off等方法，而是推荐使用mitt方案来代替")]),t._v(" "),a("ul",[a("li",[a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("import mitt from 'mitt'\nconst emitter = mitt()\n//监听一个事件\nemitter.on('foo',e =>console.log('foo',e))\n//触发事件\nemitter.emit('foo',{a:'b'})\n\n由于3.x中不再支持prototype的方式给Vue绑定静态方法，可以通过`app.config.globalProperties.mitt = () =>{}方案`\n")])])])])])])])]),t._v(" "),a("li",[a("p",[t._v("setup()中使用props和this")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("在2.x中，组建的方法中可以通过this获取当前组件的实例，并执行data变量的修改，方法的调用、组建的通信等，但在3.x中，setup()在beforeCreate和created时机就已经调用，无法使用和2.x一样的this，但是可以通过接收"),a("code",[t._v("setup(props,ctx)")]),t._v("的方法，获取当前组件的实例和props")]),t._v(" "),a("ul",[a("li",[a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("export default{\n\tprops:{\n\t\tname:String,\n\t},\n\tsetup(props,ctx){\n\t\tconsole.log(props.name)\n\t\tctx.emit('event')\n\t}\n}\n\nctx和2.x中的this并不完全一样，而是选择性地暴露了一些property,主要有[attrs,emit,slots]\n")])])])])])])])]),t._v(" "),a("li",[a("p",[t._v("watch来监听对象改变")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("2.x中，可以采用watch来监听一个对象属性是否有改动")]),t._v(" "),a("ul",[a("li",[a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("data(){\n\treturn{\n\t\tname:'a'\n\t}\n},\nwatch:{\n\tname(val){\n\t\tconsole.log(val)\n\t}\n}\n")])])])])])]),t._v(" "),a("li",[a("p",[t._v("3.x中，在setup()中，可以使用watch来监听")]),t._v(" "),a("ul",[a("li",[a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("import {watch} form 'vue'\nsetup(){\n\tlet state = reactive({\n\t\tname:\n\t})\n}\n")])])])])])])])])]),t._v(" "),a("h3",{attrs:{id:"vue3初探"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue3初探"}},[t._v("#")]),t._v(" vue3初探")]),t._v(" "),a("h6",{attrs:{id:"性能提升"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#性能提升"}},[t._v("#")]),t._v(" 性能提升")]),t._v(" "),a("ul",[a("li",[t._v("proxy响应式\n"),a("ul",[a("li",[t._v("响应式原理由Object.defineProperty改为基于ES6的Proxy")]),t._v(" "),a("li",[t._v("优点：能够规避Object.defineProperty的问题\n"),a("ul",[a("li",[t._v("深度监听:性能更好，不会递归到底而是在get到这个层级才会去递归")]),t._v(" "),a("li",[t._v("可监听数组变化")]),t._v(" "),a("li",[t._v("可监听新增、删除属性")]),t._v(" "),a("li",[t._v("但无法兼容所有浏览器并无法polyfill")])])])])]),t._v(" "),a("li",[t._v("patchFlag静态标记\n"),a("ul",[a("li",[t._v("编译模板时给动态节点做标记")]),t._v(" "),a("li",[t._v("diff算法时值会对比标记的节点")])])]),t._v(" "),a("li",[t._v("hoistStatic静态提升\n"),a("ul",[a("li",[t._v("将静态节点的定义，提升到父作用域，缓存起来")]),t._v(" "),a("li",[t._v("多个相邻的静态节点会被合并起来")])])]),t._v(" "),a("li",[t._v("cacheHandle缓存事件\n"),a("ul",[a("li",[t._v("默认情况下@click也会进行动态标记")]),t._v(" "),a("li",[t._v("增加cacheHandle会对事件进行缓存且没有PatchFlag未开启cacheHandler")])])]),t._v(" "),a("li",[t._v("SSR优化\n"),a("ul",[a("li",[t._v("静态节点直接输出绕过了vdom")]),t._v(" "),a("li",[t._v("动态节点动态渲染")])])]),t._v(" "),a("li",[t._v("tree shaking\n"),a("ul",[a("li",[t._v("编译时根据不同的情况下引入不同的API，没用到的api会进行剔除。")])])])]),t._v(" "),a("h6",{attrs:{id:"composition-api-组合api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#composition-api-组合api"}},[t._v("#")]),t._v(" Composition API：组合API")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("更好的代码组织和逻辑复用")])]),t._v(" "),a("li",[a("p",[t._v("setup:Composition API的入口点")])]),t._v(" "),a("li",[a("p",[t._v("响应式API：reacitve、ref、computed、readonly、watch、watchEffct等")])]),t._v(" "),a("li",[a("p",[t._v("新的生命周期函数：onMounted、onUpdated、onUnmounted等")])]),t._v(" "),a("li",[a("p",[a("img",{attrs:{src:"https://img-blog.csdnimg.cn/84915fc89f5b4c2b94ea6f7d331a7a98.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAeGlhb0xpYW5nIG8=,size_8,color_FFFFFF,t_70,g_se,x_16",alt:"在这里插入图片描述"}})])]),t._v(" "),a("li",[a("p",[t._v("自定义函数hooks函数")])])]),t._v(" "),a("h6",{attrs:{id:"其他新增特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#其他新增特性"}},[t._v("#")]),t._v(" 其他新增特性")]),t._v(" "),a("ul",[a("li",[t._v("Teleport：瞬移组件的位置")]),t._v(" "),a("li",[t._v("Suspense：异步加载组件")])]),t._v(" "),a("h6",{attrs:{id:"更好的ts支持"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#更好的ts支持"}},[t._v("#")]),t._v(" 更好的TS支持")]),t._v(" "),a("h6",{attrs:{id:"优势"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优势"}},[t._v("#")]),t._v(" 优势")]),t._v(" "),a("ul",[a("li",[t._v("vue2存在复杂组件的代码变得难以维护并且对TS的支持有限")]),t._v(" "),a("li",[t._v("vue3的性能更好、体积更小、更好的TS支持、更好的代码组织和逻辑抽离。")])])])}),[],!1,null,null,null);e.default=n.exports}}]);